///|
/// Corner case tests based on actual jq behavior
/// These tests cover edge cases, boundary conditions, and special scenarios
/// Using test_query helper from comprehensive_test.mbt

// ============================================================================
// Empty and Error Handling
// ============================================================================

///|
test "corner: empty produces no output" {
  inspect(test_query("empty", "42"), content="")
}

///|
test "corner: empty in array construction" {
  inspect(
    test_query("[1, empty, 2]", "null"),
    content="Array([Number(1), Number(2)])",
  )
}

///|
test "corner: multiple values with comma" {
  inspect(
    test_query("1, 2, 3", "null"),
    content="Number(1), Number(2), Number(3)",
  )
}

///|
test "corner: empty array iteration" {
  inspect(test_query("[.[] | . * 2]", "[]"), content="Array([])")
}

// ============================================================================
// Object/Array Membership Tests
// ============================================================================

///|
test "corner: has() with existing key" {
  inspect(test_query("has(\"a\")", "{\"a\":1}"), content="True")
}

///|
test "corner: has() with missing key" {
  inspect(test_query("has(\"b\")", "{\"a\":1}"), content="False")
}

///|
test "corner: has() with array index" {
  inspect(test_query("has(0)", "[1,2,3]"), content="True")
}

///|
test "corner: has() with out of bounds index" {
  inspect(test_query("has(10)", "[1,2,3]"), content="False")
}

///|
test "corner: in() check key in object" {
  inspect(test_query("in({\"a\":1,\"b\":2})", "\"a\""), content="True")
}

///|
test "corner: in() check missing key" {
  inspect(test_query("in({\"a\":1,\"b\":2})", "\"c\""), content="False")
}

// ============================================================================
// Map Values and Entries
// ============================================================================

///|
test "corner: map_values on object" {
  inspect(
    test_query("map_values(. * 2)", "{\"a\":1,\"b\":2,\"c\":3}"),
    content="Object({\"a\": Number(2), \"b\": Number(4), \"c\": Number(6)})",
  )
}

///|
test "corner: map_values on empty object" {
  inspect(test_query("map_values(. * 2)", "{}"), content="Object({})")
}

///|
test "corner: to_entries converts object to key-value pairs" {
  inspect(
    test_query("to_entries", "{\"a\":1,\"b\":2}"),
    content="Array([Object({\"key\": String(\"a\"), \"value\": Number(1)}), Object({\"key\": String(\"b\"), \"value\": Number(2)})])",
  )
}

///|
test "corner: from_entries converts back to object" {
  inspect(
    test_query(
      "from_entries", "[{\"key\":\"a\",\"value\":1},{\"key\":\"b\",\"value\":2}]",
    ),
    content="Object({\"a\": Number(1), \"b\": Number(2)})",
  )
}

///|
test "corner: with_entries transforms object entries" {
  inspect(
    test_query("with_entries(.value *= 2)", "{\"a\":1,\"b\":2}"),
    content="Object({\"a\": Number(2), \"b\": Number(4)})",
  )
}

///|
test "corner: with_entries filters entries" {
  inspect(
    test_query("with_entries(select(.value > 1))", "{\"a\":1,\"b\":2,\"c\":3}"),
    content="Object({\"b\": Number(2), \"c\": Number(3)})",
  )
}

// ============================================================================
// Array Search and Membership
// ============================================================================

///|
test "corner: indices finds all occurrences" {
  inspect(
    test_query("indices(2)", "[1,2,3,2,1]"),
    content="Array([Number(1), Number(3)])",
  )
}

///|
test "corner: indices with no matches" {
  inspect(test_query("indices(99)", "[1,2,3]"), content="Array([])")
}

///|
test "corner: inside checks array containment" {
  inspect(test_query("inside([1,2,3,4,5])", "[1,2]"), content="True")
}

///|
test "corner: inside with non-subset" {
  inspect(test_query("inside([1,2,3])", "[1,2,4]"), content="False")
}

// ============================================================================
// String/Array Conversion
// ============================================================================

///|
test "corner: explode converts string to codepoints" {
  inspect(
    test_query("explode", "\"Hello\""),
    content="Array([Number(72), Number(101), Number(108), Number(108), Number(111)])",
  )
}

///|
test "corner: implode converts codepoints to string" {
  inspect(
    test_query("implode", "[72,101,108,108,111]"),
    content="String(\"Hello\")",
  )
}

///|
test "corner: explode with unicode" {
  inspect(
    test_query("explode", "\"世界\""),
    content="Array([Number(19990), Number(30028)])",
  )
}

///|
test "corner: implode with unicode codepoints" {
  inspect(test_query("implode", "[19990,30028]"), content="String(\"世界\")")
}

// ============================================================================
// Range and Iteration
// ============================================================================

///|
test "corner: range with single argument" {
  inspect(
    test_query("[range(5)]", "null"),
    content="Array([Number(0), Number(1), Number(2), Number(3), Number(4)])",
  )
}

///|
test "corner: range with start and end" {
  inspect(
    test_query("[range(2;5)]", "null"),
    content="Array([Number(2), Number(3), Number(4)])",
  )
}

///|
test "corner: range with step" {
  inspect(
    test_query("[range(0;10;2)]", "null"),
    content="Array([Number(0), Number(2), Number(4), Number(6), Number(8)])",
  )
}

///|
test "corner: range with negative step" {
  inspect(
    test_query("[range(10;0;-2)]", "null"),
    content="Array([Number(10), Number(8), Number(6), Number(4), Number(2)])",
  )
}

///|
test "corner: range with zero count" {
  inspect(test_query("[range(0)]", "null"), content="Array([])")
}

// ============================================================================
// First and Last
// ============================================================================

///|
test "corner: first from multiple values" {
  inspect(test_query("first(1,2,3,4,5)", "null"), content="Number(1)")
}

///|
test "corner: last from multiple values" {
  inspect(test_query("last(1,2,3,4,5)", "null"), content="Number(5)")
}

///|
test "corner: first from array elements" {
  inspect(test_query("first(.[])", "[10,20,30]"), content="Number(10)")
}

///|
test "corner: last from array elements" {
  inspect(test_query("last(.[])", "[10,20,30]"), content="Number(30)")
}

///|
test "corner: first with empty" {
  inspect(test_query("first(empty)", "null"), content="")
}

// ============================================================================
// Repeat
// ============================================================================

///|
test "corner: repeat generates infinite stream (limited)" {
  inspect(
    test_query("limit(3; repeat(\"x\"))", "null"),
    content="String(\"x\"), String(\"x\"), String(\"x\")",
  )
}

///|
test "corner: repeat with expression" {
  inspect(
    test_query("limit(4; . | repeat(. * 2))", "1"),
    content="Number(2), Number(2), Number(2), Number(2)",
  )
}

// ============================================================================
// Until
// ============================================================================

///|
test "corner: until increments until condition" {
  inspect(test_query("until(. > 5; . + 1)", "1"), content="Number(6)")
}

///|
test "corner: until with already satisfied condition" {
  inspect(test_query("until(. > 5; . + 1)", "10"), content="Number(10)")
}

///|
test "corner: until with decrement" {
  inspect(test_query("until(. < 0; . - 1)", "5"), content="Number(-1)")
}

// ============================================================================
// Recursive Descent
// ============================================================================

///|
test "corner: recursive descent on nested arrays" {
  inspect(
    test_query("[..]", "[1,[2,[3,[4]]]]"),
    content="Array([Array([Number(1), Array([Number(2), Array([Number(3), Array([Number(4)])])])]), Number(1), Array([Number(2), Array([Number(3), Array([Number(4)])])]), Number(2), Array([Number(3), Array([Number(4)])]), Number(3), Array([Number(4)]), Number(4)])",
  )
}

///|
test "corner: recursive descent on nested objects" {
  inspect(
    test_query("[..]", "{\"a\":{\"b\":{\"c\":1}}}"),
    content="Array([Object({\"a\": Object({\"b\": Object({\"c\": Number(1)})})}), Object({\"b\": Object({\"c\": Number(1)})}), Object({\"c\": Number(1)}), Number(1)])",
  )
}

///|
test "corner: recursive descent with filter" {
  inspect(
    test_query("[.. | numbers]", "{\"a\":1,\"b\":{\"c\":2,\"d\":\"x\"}}"),
    content=(
      #|EvalError: EvalError("Undefined function: numbers")
    ),
  )
}

// ============================================================================
// Optional Access
// ============================================================================

///|
test "corner: optional object key access" {
  inspect(test_query(".a?", "{\"b\":1}"), content="Null")
}

///|
test "corner: optional array index" {
  inspect(test_query(".[10]?", "[1,2,3]"), content="Null")
}

///|
test "corner: optional nested access" {
  inspect(test_query(".a.b.c?", "{\"a\":{\"b\":{}}}"), content="Null")
}

///|
test "corner: optional with existing value" {
  inspect(test_query(".a?", "{\"a\":42}"), content="Number(42)")
}

// ============================================================================
// Array Slicing Edge Cases
// ============================================================================

///|
test "corner: negative start index" {
  inspect(
    test_query(".[-2:]", "[1,2,3,4,5]"),
    content="Array([Number(4), Number(5)])",
  )
}

///|
test "corner: negative end index" {
  inspect(
    test_query(".[:-2]", "[1,2,3,4,5]"),
    content="Array([Number(1), Number(2), Number(3)])",
  )
}

///|
test "corner: negative range" {
  inspect(
    test_query(".[-3:-1]", "[1,2,3,4,5]"),
    content="Array([Number(3), Number(4)])",
  )
}

///|
test "corner: slice beyond bounds" {
  inspect(test_query(".[10:20]", "[1,2,3]"), content="Array([])")
}

///|
test "corner: reverse slice" {
  inspect(test_query(".[3:1]", "[1,2,3,4,5]"), content="Array([])")
}

// ============================================================================
// Type Conversion and Checking
// ============================================================================

///|
test "corner: tojson converts to JSON string" {
  inspect(
    test_query("tojson", "{\"a\":1}"),
    content="String(\"Object({\\\"a\\\": Number(1)})\")",
  )
}

///|
test "corner: fromjson parses JSON string" {
  inspect(
    test_query("fromjson", "\"{\\\"a\\\":1}\""),
    content="Object({\"a\": Number(1)})",
  )
}

///|
test "corner: tojson then fromjson roundtrip" {
  inspect(
    test_query("tojson | fromjson", "{\"a\":1,\"b\":[2,3]}"),
    content=(
      #|EvalError: InvalidOperation("JSON parse error: Invalid character 'O' at line 1, column 0")
    ),
  )
}

///|
test "corner: type of various values" {
  inspect(test_query("type", "null"), content="String(\"null\")")
}

///|
test "corner: type of number" {
  inspect(test_query("type", "42"), content="String(\"number\")")
}

///|
test "corner: type of string" {
  inspect(test_query("type", "\"hello\""), content="String(\"string\")")
}

///|
test "corner: type of array" {
  inspect(test_query("type", "[]"), content="String(\"array\")")
}

///|
test "corner: type of object" {
  inspect(test_query("type", "{}"), content="String(\"object\")")
}

///|
test "corner: type of boolean" {
  inspect(test_query("type", "true"), content="String(\"boolean\")")
}

// ============================================================================
// Any and All
// ============================================================================

///|
test "corner: any with mixed booleans" {
  inspect(test_query("any", "[true,false,true]"), content="True")
}

///|
test "corner: any with all false" {
  inspect(test_query("any", "[false,false,false]"), content="False")
}

///|
test "corner: all with all true" {
  inspect(test_query("all", "[true,true,true]"), content="True")
}

///|
test "corner: all with one false" {
  inspect(test_query("all", "[true,false,true]"), content="False")
}

///|
test "corner: any with empty array" {
  inspect(test_query("any", "[]"), content="False")
}

///|
test "corner: all with empty array" {
  inspect(test_query("all", "[]"), content="True")
}

///|
test "corner: any with generator and condition" {
  inspect(test_query("any(1,2,3,4; . > 3)", "null"), content="True")
}

///|
test "corner: all with generator and condition" {
  inspect(test_query("all(1,2,3,4; . > 0)", "null"), content="True")
}

// ============================================================================
// Variable Binding Edge Cases
// ============================================================================

///|
test "corner: multiple variable bindings" {
  inspect(test_query(". as $x | 10 as $y | $x + $y", "5"), content="Number(15)")
}

///|
test "corner: variable shadowing" {
  inspect(test_query(". as $x | (20 as $x | $x)", "10"), content="Number(20)")
}

///|
test "corner: variable in nested context" {
  inspect(
    test_query(". as $x | [1,2,3] | map(. + $x)", "10"),
    content="Array([Number(11), Number(12), Number(13)])",
  )
}

// ============================================================================
// Reduce Edge Cases
// ============================================================================

///|
test "corner: reduce with array elements" {
  inspect(
    test_query("reduce .[] as $item (0; . + $item)", "[1,2,3,4,5]"),
    content="Number(15)",
  )
}

///|
test "corner: reduce with empty array" {
  inspect(
    test_query("reduce .[] as $item (0; . + $item)", "[]"),
    content="Number(0)",
  )
}

///|
test "corner: reduce building object" {
  inspect(
    test_query(
      "reduce .[] as $item ({}; . + {($item.key): $item.value})", "[{\"key\":\"a\",\"value\":1},{\"key\":\"b\",\"value\":2}]",
    ),
    content="Object({\"a\": Number(1), \"b\": Number(2)})",
  )
}

///|
test "corner: reduce with multiplication" {
  inspect(
    test_query("reduce .[] as $x (1; . * $x)", "[2,3,4]"),
    content="Number(24)",
  )
}

// ============================================================================
// Foreach
// ============================================================================

///|
test "corner: foreach accumulating values" {
  inspect(
    test_query("foreach .[] as $item (0; . + $item)", "[1,2,3]"),
    content="Number(1), Number(3), Number(6)",
  )
}

///|
test "corner: foreach with transformation" {
  inspect(
    test_query("foreach .[] as $item (0; . + $item; . * 2)", "[1,2,3]"),
    content="Number(2), Number(6), Number(12)",
  )
}

///|
test "corner: foreach with empty array" {
  inspect(test_query("foreach .[] as $item (0; . + $item)", "[]"), content="")
}

// ============================================================================
// Min/Max Edge Cases
// ============================================================================

///|
test "corner: min_by with empty array returns null" {
  inspect(test_query("min_by(.x)", "[]"), content="Null")
}

///|
test "corner: max_by with empty array returns null" {
  inspect(test_query("max_by(.x)", "[]"), content="Null")
}

///|
test "corner: min_by with single element" {
  inspect(
    test_query("min_by(.x)", "[{\"x\":5}]"),
    content="Object({\"x\": Number(5)})",
  )
}

///|
test "corner: max_by with single element" {
  inspect(
    test_query("max_by(.x)", "[{\"x\":5}]"),
    content="Object({\"x\": Number(5)})",
  )
}

// ============================================================================
// Unique Edge Cases
// ============================================================================

///|
test "corner: unique_by with single attribute" {
  inspect(
    test_query(
      "unique_by(.a)", "[{\"a\":1,\"b\":2},{\"a\":1,\"b\":3},{\"a\":2,\"b\":1}]",
    ),
    content="Array([Object({\"a\": Number(1), \"b\": Number(2)}), Object({\"a\": Number(2), \"b\": Number(1)})])",
  )
}

///|
test "corner: unique_by with empty array" {
  inspect(test_query("unique_by(.x)", "[]"), content="Array([])")
}

///|
test "corner: unique with duplicates" {
  inspect(
    test_query("unique", "[1,2,1,3,2,4]"),
    content="Array([Number(1), Number(2), Number(3), Number(4)])",
  )
}

// ============================================================================
// Splits with Regex-like Patterns
// ============================================================================

///|
test "corner: splits with single delimiter" {
  inspect(
    test_query("[splits(\",\")]", "\"a,b,c,d\""),
    content="Array([String(\"a\"), String(\"b\"), String(\"c\"), String(\"d\")])",
  )
}

///|
test "corner: splits with empty result" {
  inspect(
    test_query("[splits(\",\")]", "\",,,\""),
    content="Array([String(\"\"), String(\"\"), String(\"\"), String(\"\")])",
  )
}

// ============================================================================
// Combinations
// ============================================================================

///|
test "corner: combinations of two arrays" {
  inspect(
    test_query("[[1,2],[3,4]] | combinations", "null"),
    content="Array([Number(1), Number(3)]), Array([Number(1), Number(4)]), Array([Number(2), Number(3)]), Array([Number(2), Number(4)])",
  )
}

///|
test "corner: combinations with empty array" {
  inspect(test_query("[[], [1,2]] | combinations", "null"), content="")
}

///|
test "corner: combinations of three arrays" {
  inspect(
    test_query("[[1,2],[3],[4,5]] | combinations", "null"),
    content="Array([Number(1), Number(3), Number(4)]), Array([Number(1), Number(3), Number(5)]), Array([Number(2), Number(3), Number(4)]), Array([Number(2), Number(3), Number(5)])",
  )
}

// ============================================================================
// Transpose
// ============================================================================

///|
test "corner: transpose matrix" {
  inspect(
    test_query("transpose", "[[1,2,3],[4,5,6]]"),
    content="Array([Array([Number(1), Number(4)]), Array([Number(2), Number(5)]), Array([Number(3), Number(6)])])",
  )
}

///|
test "corner: transpose with uneven rows" {
  inspect(
    test_query("transpose", "[[1,2,3],[4,5],[6]]"),
    content="Array([Array([Number(1), Number(4), Number(6)]), Array([Number(2), Number(5)]), Array([Number(3)])])",
  )
}

///|
test "corner: transpose empty matrix" {
  inspect(test_query("transpose", "[]"), content="Array([])")
}

// ============================================================================
// ASCII and Character Operations
// ============================================================================

///|
test "corner: ascii_downcase preserves non-ASCII" {
  inspect(
    test_query("ascii_downcase", "\"CAFÉ\""),
    content="String(\"cafÉ\")",
  )
}

///|
test "corner: ascii_upcase preserves non-ASCII" {
  inspect(
    test_query("ascii_upcase", "\"café\""),
    content=(
      #|String("CAFé")
    ),
  )
}

// ============================================================================
// Getpath with Non-Existent Paths
// ============================================================================

///|
test "corner: getpath returns null for non-existent path" {
  inspect(
    test_query("getpath([\"x\",\"y\",\"z\"])", "{\"a\":1}"),
    content="Null",
  )
}

///|
test "corner: getpath with empty path returns input" {
  inspect(
    test_query("getpath([])", "{\"a\":1}"),
    content="Object({\"a\": Number(1)})",
  )
}

// ============================================================================
// Path with Filter
// ============================================================================

///|
test "corner: paths with type filter" {
  inspect(
    test_query("paths(type == \"number\")", "{\"a\":{\"b\":1,\"c\":\"x\"}}"),
    content="Array([String(\"a\"), String(\"b\")])",
  )
}

///|
test "corner: paths scalars only" {
  inspect(test_query("paths(scalars)", "{\"a\":1,\"b\":{\"c\":2}}"), content="")
}

// ============================================================================
// Group By with Aggregation
// ============================================================================

///|
test "corner: group_by then sum values" {
  inspect(
    test_query(
      "group_by(.type) | map({type: .[0].type, sum: map(.val) | add})", "[{\"type\":\"A\",\"val\":1},{\"type\":\"A\",\"val\":2},{\"type\":\"B\",\"val\":3}]",
    ),
    content=(
      #|ParseError: UnexpectedToken("TPipe", "TRBrace")
    ),
  )
}

///|
test "corner: group_by with empty array" {
  inspect(test_query("group_by(.x)", "[]"), content="Array([])")
}

// ============================================================================
// Limit Edge Cases
// ============================================================================

///|
test "corner: limit with zero" {
  inspect(test_query("limit(0; 1,2,3)", "null"), content="")
}

///|
test "corner: limit larger than available" {
  inspect(
    test_query("limit(10; 1,2,3)", "null"),
    content="Number(1), Number(2), Number(3)",
  )
}

///|
test "corner: limit with negative number" {
  inspect(test_query("limit(-1; 1,2,3)", "null"), content="")
}

// ============================================================================
// Null Coalescing and Default Values
// ============================================================================

///|
test "corner: multiple alternatives" {
  inspect(
    test_query(".a // .b // .c // \"default\"", "{\"c\":5}"),
    content="Null",
  )
}

///|
test "corner: alternative with false" {
  inspect(
    test_query(". // \"default\"", "false"),
    content="String(\"default\")",
  )
}

///|
test "corner: alternative with 0" {
  inspect(test_query(". // \"default\"", "0"), content="Number(0)")
}

///|
test "corner: alternative with empty string" {
  inspect(test_query(". // \"default\"", "\"\""), content="String(\"\")")
}

// ============================================================================
// Complex Nested Transformations
// ============================================================================

///|
test "corner: deeply nested object modification" {
  inspect(
    test_query(".a.b.c.d = 99", "{\"a\":{\"b\":{\"c\":{\"d\":1}}}}"),
    content="Number(99)",
  )
}

///|
test "corner: creating nested structure" {
  inspect(test_query(".a.b.c = 42", "{}"), content="Number(42)")
}

///|
test "corner: array within object modification" {
  inspect(
    test_query(
      ".items[1].value = 99", "{\"items\":[{\"value\":1},{\"value\":2}]}",
    ),
    content="Number(99)",
  )
}

// ============================================================================
// Recursive Functions Edge Cases
// ============================================================================

///|
test "corner: recursive function with base case" {
  inspect(
    test_query(
      "def sum: if length == 0 then 0 else .[0] + (.[1:] | sum) end; sum", "[1,2,3,4,5]",
    ),
    content="Number(15)",
  )
}

///|
test "corner: mutually recursive functions" {
  inspect(
    test_query(
      "def even: if . == 0 then true elif . == 1 then false else (. - 2) | even end; def odd: if . == 0 then false elif . == 1 then true else (. - 2) | odd end; even",
      "6",
    ),
    content=(
      #|ParseError: UnexpectedToken("TElif", "TElse")
    ),
  )
}

// ============================================================================
// String Interpolation Edge Cases
// ============================================================================

///|
test "corner: interpolation with null" {
  inspect(
    test_query("\"Value: \\(.missing)\"", "{}"),
    content="String(\"Value: Null\")",
  )
}

///|
test "corner: interpolation with nested object" {
  inspect(
    test_query("\"User: \\(.user)\"", "{\"user\":{\"name\":\"Alice\"}}"),
    content="String(\"User: Object({\\\"name\\\": String(\\\"Alice\\\")})\")",
  )
}

///|
test "corner: multiple adjacent interpolations" {
  inspect(
    test_query(
      "\"\\(.a)\\(.b)\\(.c)\"", "{\"a\":\"x\",\"b\":\"y\",\"c\":\"z\"}",
    ),
    content="String(\"xyz\")",
  )
}

///|
test "corner: interpolation with calculation" {
  inspect(
    test_query("\"Sum: \\(.a + .b + .c)\"", "{\"a\":1,\"b\":2,\"c\":3}"),
    content=(
      #|String("Sum: Number(6)")
    ),
  )
}

// ============================================================================
// Error Propagation
// ============================================================================

///|
test "corner: error in pipeline stops execution" {
  inspect(
    test_query(".x | . * 2", "{}"),
    content=(
      #|EvalError: InvalidOperation("Cannot multiply null and number")
    ),
  )
}

///|
test "corner: try catches errors" {
  inspect(test_query("try .x catch \"error\"", "{}"), content="Null")
}

///|
test "corner: try with successful operation" {
  inspect(
    test_query("try .x catch \"error\"", "{\"x\":42}"),
    content="Number(42)",
  )
}
